---
title: "On Zig as a C++ Build System"
description: "Testing the capabilities of zig as a build system for C and C++ projects by using it to build a raylib project with C++"
pubDate: "September 13 2024"
tags:
  - raylib
  - c++
  - zig
---

Zig sparks absolutely no interest in me as a _language_, but it does seem like it could be a compelling build tool for existing C and C++ projects due to its integrations with clang and musl that makes it easy to cross compile and even set specific versions of libraries like `glibc`. I have little experience with the language, but I wanted to see whether I could build a C++ project with dependencies successfully, meaning all the necessary libraries would be linked and it would conveniently output header files in a reasonable location for any editor to find (I use Neovim btw.).

<br />

## The Project

The project I wanted to build is a C++ project which depends on `raylib` and `raylib-cpp`. [Raylib](https://github.com/raysan5/raylib) is basically an abstraction layer over different platform graphics systems, with some convenient APIs for 2D and 3D game development. It's written in C. The raylib-cpp dependency is a header-only C++ library which provides an object-oriented wrapper around the core raylib APIs.

<br />

The structure of the project is just three files:

```bash showLineNumbers=false frame="none"
(root)
├── build.zig
├── build.zig.zon
└── main.cc
```

Put the following in your `main.cc` file. By the end of this post, you should not get any build or IDE errors.

```c++ title="main.cc"
#include <raylib-cpp.hpp>

int main(int argc, char **argv) {
  int screenWidth = 800;
  int screenHeight = 450;

  raylib::Window window(screenWidth, screenHeight, "raylib-cpp - basic window");

  window.SetTargetFPS(60);

  while (!window.ShouldClose()) {
    window.BeginDrawing();

    window.ClearBackground(raylib::Color::RayWhite());

    raylib::DrawText("Congrats! You created your first window!", 190, 200, 20, raylib::Color::LightGray());

    window.EndDrawing();
  }

  return 0;
}
```

Now for the fun stuff.

<br />

## Specifying Our Dependencies

<br />

Zig is not stable. APIs are subject to breakage with each release, and the tooling, while impressive for a pre-1.0 language, has many rough edges. An example of this is the lack of an ergonomic package manager. Coming from the Rust and Go worlds, `build.zig.zon` is far cry from `cargo add` or `go get`, but it is all we have to work with. The `build.zig.zon` file specifies dependencies in Zig Object Notation, which looks pretty similar to JSON (with more punctuation). The possible top level keys are specified in the [documentation](https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md) (there aren't very many). We can start off our `build.zig.zon` with the following:

```zig title="build.zig.zon"

.{
    .name = "proof-of-concept",
    .version = "0.0.1",
    .dependencies = .{},

    .paths = .{"build.zig"},
}

```

Each dependency is a struct which may include the following keys:

- url
- hash
- path

<br />

You must either provide a url and a hash, or a path. We will be using some C and C++ libraries from GitHub, and won't have any actual zig code in our project at all (although there are zig bindings for raylib)<sup>1</sup>. The url of a GitHub dependency in `build.zig.zon` is not the GitHub URL for the project, but rather a link to the zipped (.tar.gz) project. To retrieve this for a branch, go where you normally would to clone the project and copy the "Download ZIP" link. You can also do this for tags by copying the tar.gz URL for the tag. This sounds confusing, but really isn't difficult in practice. Let's add raylib as a dependency.

```zig title="build.zig.zon" ins={5-7}
.{
    .name = "proof-of-concept",
    .version = "0.0.1",
    .dependencies = .{
        .raylib = .{
            .url = "https://github.com/raysan5/raylib/archive/52f2a10db610d0e9f619fd7c521db08a876547d0.tar.gz",
        },
    },

    .paths = .{"build.zig"},
}
```

We also need to specify a hash. To get this hash, you can run `zig fetch <url>`. Update your `build.zig.zon` with the hash printed to the console like so:

```zig title="build.zig.zon" ins={7}
.{
    .name = "proof-of-concept",
    .version = "0.0.1",
    .dependencies = .{
        .raylib = .{
            .url = "https://github.com/raysan5/raylib/archive/52f2a10db610d0e9f619fd7c521db08a876547d0.tar.gz",
            .hash = "1220761aef32a253042bf79d5acc4c2013853f4db5a9a9f68cd341ee4ddb9099803a", // master
        },
    },

    .paths = .{"build.zig"},
}
```

The second dependency we need for our project is the [C++ bindings for raylib](https://github.com/RobLoach/raylib-cpp). We can add another dependency to our project like so:

```zig title="build.zig.zon" ins={9-12}
.{
    .name = "proof-of-concept",
    .version = "0.0.1",
    .dependencies = .{
        .raylib = .{
            .url = "https://github.com/raysan5/raylib/archive/52f2a10db610d0e9f619fd7c521db08a876547d0.tar.gz",
            .hash = "1220761aef32a253042bf79d5acc4c2013853f4db5a9a9f68cd341ee4ddb9099803a", // master
        },
        .@"raylib-cpp" = .{
            .url = "https://github.com/RobLoach/raylib-cpp/archive/refs/tags/v5.0.2.tar.gz",
            .hash = "12200de71a671fc3b2155475bc6691c51ac1ce81f4910fb0db9cad579a1047877108",
        },
    },

    .paths = .{"build.zig"},
}
```

This dependency is pinned to the `5.0.2` (most recent as of September 13, 2024) tag on the repository. If you need a newer version, just `zig fetch <url>` for the version you want.

<br />

## Writing a Build File

<br />

Start with the following in your `build.zig`. This just sets up an executable with a single source file (`main.cc`), with default target and optimization options. It also links `libc` and `libcpp` so the standard libraries for C and C++ are accessible.

```zig title="build.zig"
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "proof-of-concept",
        .target = target,
        .optimize = optimize,
    });

    exe.addCSourceFile(.{
        .file = b.path("main.cc"),
    });
    exe.linkLibC();
    exe.linkLibCpp();

    b.installArtifact(exe);
}
```

Now we can add our dependencies.

<br />

Since raylib has a `build.zig` file, we have an easy time installing it. We can reference the dependency by its name in `build.zig.zon`, create an artifact, link the artifact to the executable, and install the headers alongside the executable. The headers will show up under `/zig-out/include`.

```zig title="build.zig" ins={19-27}
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "proof-of-concept",
        .target = target,
        .optimize = optimize,
    });

    exe.addCSourceFile(.{
        .file = b.path("main.cc"),
    });
    exe.linkLibC();
    exe.linkLibCpp();

    const raylib = b.dependency("raylib", .{
        .target = target,
        .optimize = optimize,
    });
    const raylibArtifact = raylib.artifact("raylib");

    exe.linkLibrary(raylibArtifact);

    b.installArtifact(raylibArtifact);

    b.installArtifact(exe);
}
```

The C++ bindings to raylib are a little more complicated to add as a dependency, but it's still not too difficult–you just can't make it an artifact the way you can with raylib<sup>2</sup>.

```zig title="build.zig" ins={25-28,31,34-40}
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "proof-of-concept",
        .target = target,
        .optimize = optimize,
    });

    exe.addCSourceFile(.{
        .file = b.path("main.cc"),
    });
    exe.linkLibC();
    exe.linkLibCpp();

    const raylib = b.dependency("raylib", .{
        .target = target,
        .optimize = optimize,
    });
    const raylibArtifact = raylib.artifact("raylib");

    const raylibCpp = b.dependency("raylib-cpp", .{
        .target = target,
        .optimize = optimize,
    });

    exe.linkLibrary(raylibArtifact);
    exe.addIncludePath(raylibCpp.path("include"));

    b.installArtifact(raylibArtifact);
    b.installDirectory(
        .{
            .source_dir = raylibCpp.path("include"),
            .install_dir = .header,
            .install_subdir = "",
        },
    );

    b.installArtifact(exe);
}
```

These additions add `raylib-cpp` as a dependency, adds the include path of `raylib-cpp`, and installs the include directory into the header directory of `/zig-out`, which is called `include`.

<br />

The last thing we can do is add a run command (kind of like a `cmake` target). This is easy. Just add the following lines at the bottom.

```zig title="build.zig" collapse={4-43} ins={44-46}
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "proof-of-concept",
        .target = target,
        .optimize = optimize,
    });

    exe.addCSourceFile(.{
        .file = b.path("main.cc"),
    });
    exe.linkLibC();
    exe.linkLibCpp();

    const raylib = b.dependency("raylib", .{
        .target = target,
        .optimize = optimize,
    });
    const raylibArtifact = raylib.artifact("raylib");

    const raylibCpp = b.dependency("raylib-cpp", .{
        .target = target,
        .optimize = optimize,
    });

    exe.linkLibrary(raylibArtifact);
    exe.addIncludePath(raylibCpp.path("include"));

    b.installArtifact(raylibArtifact);
    b.installDirectory(
        .{
            .source_dir = raylibCpp.path("include"),
            .install_dir = .header,
            .install_subdir = "",
        },
    );

    b.installArtifact(exe);

    const run = b.addRunArtifact(exe);
    const run_step = b.step("run", "Run the application");
    run_step.dependOn(&run.step);
}
```

Now if you run `zig build`, your project will be built and linked properly, and if you run `zig build run`, your application will also run after its built.

<br />

## Editor Support

<br />

The header files are located under `/zig-out/include`. You'll need to add this to your IDE search path in order to make the _header not found_ errors go away. I use neovim with `clangd` as my C++ LSP, so I just add the following to a `.clangd` file and restart my LSP to get IDE functionality.

```yaml title=".clangd"
CompileFlags:
  Add:
    - "-I<path-to-root>/zig-out/include"
```

For VSCode, I'm pretty sure you just have to modify a `.vscode/settings.json` file to override/append to your include path.

<br />

Anyway, hope this was informative. It was interesting working with zig, and while I don't really see its value proposition as a language, it seems like a very promising build tool for C and C++ projects.

<br />

## Addendums

1. There are [zig bindings to raylib](https://github.com/Not-Nik/raylib-zig), but I _really_ wouldn't recommend using zig for actual production code outside of small, hobby projects. It's fine as a build system because of its cross compile capabilities and abstractions over clang, but, at the end of the day, its unstable. Use it for larger projects at your own risk. In my opinion, its LSP/editor support is lacking, its documentation is anemic, and you are expected to regularly read the source code of the standard library to keep up with breaking API changes which leads to a poor developer experience. I just wanted to include a link to the zig bindings for completeness.

2. Header-only libraries like `raylib-cpp` are easy to include the way we do in this project. For projects which involve both source and header files, you will need to actually build the library with, for example,

```zig title="build.zig"
pub fn build(b: *std.build.Builder) void {
    const target = b.standardTargetOptions(.{});
    const mode = b.standardReleaseOptions();

    const lib = b.addStaticLibrary("lib", null);
    lib.setTarget(target);
    lib.setBuildMode(mode);
    lib.linkLibC();
    lib.force_pic = true;
    lib.addCSourceFiles(&.{
      // source files
    }, &.{
      // compiler flags
    });

    // the rest of your build
}
```

If some of this syntax is wrong or outdated...oh well, I adapted it from [this blog post]("https://zig.news/kristoff/make-zig-your-c-c-build-system-28g5") and it was written in 2021 and have not tested it (unlike the code in the rest of this post). Do your best to patch the above if you need to build a library with both sources and headers.

<br />
